[{"title":"java中hashcode()、equals()和==的作用、区别和联系","url":"/java中hashcode()、equals()和==的作用、区别和联系/","content":"\n转载自别人总结，个人感觉很详细：\n\n[Java 内存分配全面浅析_tianjinsong的专栏-CSDN博客](https://blog.csdn.net/bluetjs/article/details/52874711)\n\n*<!-- more -->*\n\n个人感觉写的超级详细，文章底部的参考文献也很重要，值得仔细阅读！","tags":["hashcode","equal"],"categories":["java基础"]},{"title":"引起浏览器报错Invalid-bound-statement的各种原因","url":"/引起浏览器报错Invalid-bound-statement的各种原因/","content":"\n从报的错误信息可以看出，dao和mapper的映射关系上出现了绑定异常。\n\n*<!-- more -->*\n\n如图500异常：![](https://cdn.jsdelivr.net/gh/lirong765/hexo-image/引起浏览器报错Invalid-bound-statement的各种原因/image-20201114223439294.png)\n\n有三个原因：\n\n1、mapper文件写在Java目录下的文件夹里。\n\n![](https://cdn.jsdelivr.net/gh/lirong765/hexo-image/引起浏览器报错Invalid-bound-statement的各种原因/image-20201115095454761.png)\n\n​\t\t这种情况当idea将代码编译为.class文件并放入target目录下的同时，xml文件并没有被自动拉到target里面。因为idea默认不会识别Java目录下的xml，这时候应该在pom文件中加上：\n\n```xml\n<build>\n    <resources>\n        <resource>\n            <directory>src/main/java</directory>\n            <includes>\n                <include>**/*.xml</include><!-- 新添加 */代表1级目录 **/代表多级目录 -->\n            </includes>\n            <filtering>true</filtering>\n        </resource>\n        <resource>\n            <directory>src/main/resources</directory>\n            <includes>\n                <include>**/*.xml</include><!-- 新添加 */代表1级目录 **/代表多级目录 -->\n                <include>**/*.properties</include>\n            </includes>\n            <filtering>true</filtering>\n        </resource>\n    </resources>\n</build>\n```\n\n​\t\t但是这样有个弊端，就是在写dao层的时候接口和映射文件太多，不容易查找，所以在下面会推荐第二种方法，但是可能会出现原因三。\n\n2、在resources目录下，新建dao接口下的同级目录，将mapper文件保存其中，如图：\n\n![](https://cdn.jsdelivr.net/gh/lirong765/hexo-image/引起浏览器报错Invalid-bound-statement的各种原因/image-20201115102738724.png)\n\n\n\n​\t这种情况也可能会产生以上错误，检查spring.xml配置中的如下代码，将mapper文件路径填对即可。\n\n```java\n<bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n    <!--配置数据源-->\n    <property name=\"dataSource\" ref=\"dataSource\"></property>\n    <!--绑定Mybatis全局配置文件-->\n    <property name=\"configLocation\" value=\"classpath:sqlMapConfig.xml\"></property>\n    <property name=\"mapperLocations\" value=\"classpath:com/rong/dao/*.xml\" />\n</bean>\n```\n\n3、xml里面的namespace不对，或者id和mapper里面的方法名不一样，或者parameterType对应不上，都会出现这种问题。\n\n```xml\n<!--一个接口对应一个mapper-->\n<mapper namespace=\"com.rong.dao.BookMapper\">\n    <insert id=\"addBook\" parameterType=\"Books\">\n        insert into ssmbuild.books (bookName, bookCounts, detail)\n            values (#{bookName},#{bookCounts},#{detail});\n    </insert>\n</mapper>\n```\n\n","categories":["idea/浏览器报错"]},{"title":"Tomcat部署时war包和war explored的区别","url":"/Tomcat部署时war包和war-explored的区别/","content":"\n转自链接：<https://blog.csdn.net/xlgen157387/article/details/56498938>\n\n> **war模式：将WEB工程以包的形式上传到服务器**\n>\n> **war exploded模式：将WEB工程以当前文件夹的位置关系上传到服务器**\n\n<!-- more -->\n\n&nbsp;（1）war模式这种可以称之为是发布模式，看名字也知道，这是先打成war包，再发布；\n\n&nbsp;（2）war exploded模式是直接把文件夹、jsp页面 、classes等等移到Tomcat 部署文件夹里面，进行加载部署。因此这种方式支持热部署，一般在开发的时候也是用这种方式。\n\n&nbsp;（3）在平时开发的时候，使用热部署的话，应该对Tomcat进行相应的设置，这样的话修改的jsp界面什么的东西才可以及时的显示出来。","tags":["war","war exploded"],"categories":["Tomcat"]},{"title":"SQL中Date与DataTime的区别","url":"/SQL中Date与DataTime的区别/","content":"\n## Data与DateTime的区别：\n\n　Date:代表xxxx年xx月xx日  只表示前面的日期，可以表示的日期范围为 0001 年 1 月 1 日 到 9999 年 12 月 31 日 需要3个字节的存储空间\n\n　DateTime:代表xxxx年xx月xx日xx时xx分xx秒   精确到时分秒,用于做时间戳。可以表示的范围为1753年1月1日 00:00:00到9999年12月31日 23:59:59:997，精度为 3.33 毫秒，占8个字节，默认时间 1900-01-01 00:00:00\n\n------\n\n<!-- more -->\n\n## 补充整理一下mySql中日期类型\n\n**DATE()** \n\n日期。格式：YYYY-MM-DD\n\n注释：支持的范围是从 '1000-01-01' 到 '9999-12-31\n\n \n\n**DATETIME()**\n\n*日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS\n\n注释：支持的范围是从 '1000-01-01 00:00:00' 到 '9999-12-31 23:59:59'\n\n \n\n**TIMESTAMP()**\n\n时间戳。TIMESTAMP 值使用 Unix 纪元('1970-01-01 00:00:00' UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS\n\n注释：支持的范围是从 '1970-01-01 00:00:01' UTC 到 '2038-01-09 03:14:07' UTC","tags":["data","dataTime"],"categories":["SQL"]},{"title":"java脚本在jsp页面中的使用","url":"/java脚本在jsp页面中的使用/","content":"\n# java中的<% %>,<%! %>,<%= %>区别\n\n转自：<https://www.cnblogs.com/archer-wen/p/9496007.html>\n\n\n\n   　首先，我们要了解jsp运行原理。JSP的本质就是一个Servlet，JSP的运行之前会先被Tomcat服务器翻译为.java文件，然后在将.java文本编译为.class文件，而我们在访问jsp时，处理请求的就是那个翻译后的类。\n\n<!-- more -->\n\n　　1.<% %>叫做脚本片段，其中写的内容会翻译在Servlet的Service方法中，显然我们可以在Service方法中定义局部变量或者调用其他方法，但是不能在Service中再定义其他的方法，也就是我们可以在<%%>中定义局部变量或者调用方法，但不能定义方法。在jsp页面可以有多个脚本片段，但是多个脚本片段之间要保证结构完整。\n\n\n　　2.<%! %>称作声明，其中写的内容将来会直接翻译在Servlet类中，因为我们可以在类中定义方法和属性以及全局变量，所以我们可以在<%!%>中声明方法、属性、全局变量。\n\n　　3.<%= %>称作jsp表达式，用于将已经声明的变量或者表达式输出到网页上面。　　\n\n　　4.直接写在jsp页面<body></body>中的代码称作模板元素，将来会Servlet的Service方法中的out.write(\"___\")中，作为输出内容。","tags":["jsp","java脚本"],"categories":["jsp"]},{"title":"异常处理","url":"/异常处理/","content":"\n# 异常处理\n**两种途径：**\n\n1. 方法可用throw关键词抛出异常对象,并且可能会抛出异常的方法必须声明成throws Exception。\n   - 方法抛出异常时，方法会从栈上立即被取出，而异常会再度丢给栈上的方法，也就是调用方，如果调用方继续向上抛出异常，直到try{}catch处捕获；\n   - 如果到了主方法（main方法）仍没有捕获，继续声明异常抛出，异常就由java虚拟机（java运行环境）处理。\n1. try/catch：如果要处理异常状况，就把调用包在try/catch块中，并将异常处理/恢复程序放在catch中。\n```java\npublic void takeRisk() throws BadException{\n\tif(abandonAllHope){\n\t\tthrow new IOException();\t//异常是一个对象\n\t}\n}\npublic void tt(){\n\ttry{\n\t\tanObject.takeRisk();\n\t} catch (BadException ex){\n\t\tSystem.out.println(\"发生异常！\");\n\t\tex.printStackTrace();\t//如果发生异常，printStackTrace()可以列出来关于异常的有用信息\n\t}\n}\n```","tags":["throw异常"],"categories":["java基础"]}]